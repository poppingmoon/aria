// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'broadcast.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$EmojiAdded {

 Emoji get emoji;
/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$EmojiAddedCopyWith<EmojiAdded> get copyWith => _$EmojiAddedCopyWithImpl<EmojiAdded>(this as EmojiAdded, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is EmojiAdded&&(identical(other.emoji, emoji) || other.emoji == emoji));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,emoji);

@override
String toString() {
  return 'EmojiAdded(emoji: $emoji)';
}


}

/// @nodoc
abstract mixin class $EmojiAddedCopyWith<$Res>  {
  factory $EmojiAddedCopyWith(EmojiAdded value, $Res Function(EmojiAdded) _then) = _$EmojiAddedCopyWithImpl;
@useResult
$Res call({
 Emoji emoji
});


$EmojiCopyWith<$Res> get emoji;

}
/// @nodoc
class _$EmojiAddedCopyWithImpl<$Res>
    implements $EmojiAddedCopyWith<$Res> {
  _$EmojiAddedCopyWithImpl(this._self, this._then);

  final EmojiAdded _self;
  final $Res Function(EmojiAdded) _then;

/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? emoji = null,}) {
  return _then(_self.copyWith(
emoji: null == emoji ? _self.emoji : emoji // ignore: cast_nullable_to_non_nullable
as Emoji,
  ));
}
/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$EmojiCopyWith<$Res> get emoji {
  
  return $EmojiCopyWith<$Res>(_self.emoji, (value) {
    return _then(_self.copyWith(emoji: value));
  });
}
}


/// Adds pattern-matching-related methods to [EmojiAdded].
extension EmojiAddedPatterns on EmojiAdded {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _EmojiAdded value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _EmojiAdded() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _EmojiAdded value)  $default,){
final _that = this;
switch (_that) {
case _EmojiAdded():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _EmojiAdded value)?  $default,){
final _that = this;
switch (_that) {
case _EmojiAdded() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( Emoji emoji)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _EmojiAdded() when $default != null:
return $default(_that.emoji);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( Emoji emoji)  $default,) {final _that = this;
switch (_that) {
case _EmojiAdded():
return $default(_that.emoji);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( Emoji emoji)?  $default,) {final _that = this;
switch (_that) {
case _EmojiAdded() when $default != null:
return $default(_that.emoji);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable(createToJson: false)

class _EmojiAdded implements EmojiAdded {
  const _EmojiAdded({required this.emoji});
  factory _EmojiAdded.fromJson(Map<String, dynamic> json) => _$EmojiAddedFromJson(json);

@override final  Emoji emoji;

/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$EmojiAddedCopyWith<_EmojiAdded> get copyWith => __$EmojiAddedCopyWithImpl<_EmojiAdded>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _EmojiAdded&&(identical(other.emoji, emoji) || other.emoji == emoji));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,emoji);

@override
String toString() {
  return 'EmojiAdded(emoji: $emoji)';
}


}

/// @nodoc
abstract mixin class _$EmojiAddedCopyWith<$Res> implements $EmojiAddedCopyWith<$Res> {
  factory _$EmojiAddedCopyWith(_EmojiAdded value, $Res Function(_EmojiAdded) _then) = __$EmojiAddedCopyWithImpl;
@override @useResult
$Res call({
 Emoji emoji
});


@override $EmojiCopyWith<$Res> get emoji;

}
/// @nodoc
class __$EmojiAddedCopyWithImpl<$Res>
    implements _$EmojiAddedCopyWith<$Res> {
  __$EmojiAddedCopyWithImpl(this._self, this._then);

  final _EmojiAdded _self;
  final $Res Function(_EmojiAdded) _then;

/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? emoji = null,}) {
  return _then(_EmojiAdded(
emoji: null == emoji ? _self.emoji : emoji // ignore: cast_nullable_to_non_nullable
as Emoji,
  ));
}

/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$EmojiCopyWith<$Res> get emoji {
  
  return $EmojiCopyWith<$Res>(_self.emoji, (value) {
    return _then(_self.copyWith(emoji: value));
  });
}
}


/// @nodoc
mixin _$EmojiUpdated {

 List<Emoji> get emojis;
/// Create a copy of EmojiUpdated
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$EmojiUpdatedCopyWith<EmojiUpdated> get copyWith => _$EmojiUpdatedCopyWithImpl<EmojiUpdated>(this as EmojiUpdated, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is EmojiUpdated&&const DeepCollectionEquality().equals(other.emojis, emojis));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(emojis));

@override
String toString() {
  return 'EmojiUpdated(emojis: $emojis)';
}


}

/// @nodoc
abstract mixin class $EmojiUpdatedCopyWith<$Res>  {
  factory $EmojiUpdatedCopyWith(EmojiUpdated value, $Res Function(EmojiUpdated) _then) = _$EmojiUpdatedCopyWithImpl;
@useResult
$Res call({
 List<Emoji> emojis
});




}
/// @nodoc
class _$EmojiUpdatedCopyWithImpl<$Res>
    implements $EmojiUpdatedCopyWith<$Res> {
  _$EmojiUpdatedCopyWithImpl(this._self, this._then);

  final EmojiUpdated _self;
  final $Res Function(EmojiUpdated) _then;

/// Create a copy of EmojiUpdated
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? emojis = null,}) {
  return _then(_self.copyWith(
emojis: null == emojis ? _self.emojis : emojis // ignore: cast_nullable_to_non_nullable
as List<Emoji>,
  ));
}

}


/// Adds pattern-matching-related methods to [EmojiUpdated].
extension EmojiUpdatedPatterns on EmojiUpdated {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _EmojiUpdated value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _EmojiUpdated() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _EmojiUpdated value)  $default,){
final _that = this;
switch (_that) {
case _EmojiUpdated():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _EmojiUpdated value)?  $default,){
final _that = this;
switch (_that) {
case _EmojiUpdated() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( List<Emoji> emojis)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _EmojiUpdated() when $default != null:
return $default(_that.emojis);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( List<Emoji> emojis)  $default,) {final _that = this;
switch (_that) {
case _EmojiUpdated():
return $default(_that.emojis);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( List<Emoji> emojis)?  $default,) {final _that = this;
switch (_that) {
case _EmojiUpdated() when $default != null:
return $default(_that.emojis);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable(createToJson: false)

class _EmojiUpdated implements EmojiUpdated {
  const _EmojiUpdated({required final  List<Emoji> emojis}): _emojis = emojis;
  factory _EmojiUpdated.fromJson(Map<String, dynamic> json) => _$EmojiUpdatedFromJson(json);

 final  List<Emoji> _emojis;
@override List<Emoji> get emojis {
  if (_emojis is EqualUnmodifiableListView) return _emojis;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_emojis);
}


/// Create a copy of EmojiUpdated
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$EmojiUpdatedCopyWith<_EmojiUpdated> get copyWith => __$EmojiUpdatedCopyWithImpl<_EmojiUpdated>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _EmojiUpdated&&const DeepCollectionEquality().equals(other._emojis, _emojis));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_emojis));

@override
String toString() {
  return 'EmojiUpdated(emojis: $emojis)';
}


}

/// @nodoc
abstract mixin class _$EmojiUpdatedCopyWith<$Res> implements $EmojiUpdatedCopyWith<$Res> {
  factory _$EmojiUpdatedCopyWith(_EmojiUpdated value, $Res Function(_EmojiUpdated) _then) = __$EmojiUpdatedCopyWithImpl;
@override @useResult
$Res call({
 List<Emoji> emojis
});




}
/// @nodoc
class __$EmojiUpdatedCopyWithImpl<$Res>
    implements _$EmojiUpdatedCopyWith<$Res> {
  __$EmojiUpdatedCopyWithImpl(this._self, this._then);

  final _EmojiUpdated _self;
  final $Res Function(_EmojiUpdated) _then;

/// Create a copy of EmojiUpdated
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? emojis = null,}) {
  return _then(_EmojiUpdated(
emojis: null == emojis ? _self._emojis : emojis // ignore: cast_nullable_to_non_nullable
as List<Emoji>,
  ));
}


}


/// @nodoc
mixin _$EmojiDeleted {

 List<Emoji> get emojis;
/// Create a copy of EmojiDeleted
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$EmojiDeletedCopyWith<EmojiDeleted> get copyWith => _$EmojiDeletedCopyWithImpl<EmojiDeleted>(this as EmojiDeleted, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is EmojiDeleted&&const DeepCollectionEquality().equals(other.emojis, emojis));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(emojis));

@override
String toString() {
  return 'EmojiDeleted(emojis: $emojis)';
}


}

/// @nodoc
abstract mixin class $EmojiDeletedCopyWith<$Res>  {
  factory $EmojiDeletedCopyWith(EmojiDeleted value, $Res Function(EmojiDeleted) _then) = _$EmojiDeletedCopyWithImpl;
@useResult
$Res call({
 List<Emoji> emojis
});




}
/// @nodoc
class _$EmojiDeletedCopyWithImpl<$Res>
    implements $EmojiDeletedCopyWith<$Res> {
  _$EmojiDeletedCopyWithImpl(this._self, this._then);

  final EmojiDeleted _self;
  final $Res Function(EmojiDeleted) _then;

/// Create a copy of EmojiDeleted
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? emojis = null,}) {
  return _then(_self.copyWith(
emojis: null == emojis ? _self.emojis : emojis // ignore: cast_nullable_to_non_nullable
as List<Emoji>,
  ));
}

}


/// Adds pattern-matching-related methods to [EmojiDeleted].
extension EmojiDeletedPatterns on EmojiDeleted {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _EmojiDeleted value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _EmojiDeleted() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _EmojiDeleted value)  $default,){
final _that = this;
switch (_that) {
case _EmojiDeleted():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _EmojiDeleted value)?  $default,){
final _that = this;
switch (_that) {
case _EmojiDeleted() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( List<Emoji> emojis)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _EmojiDeleted() when $default != null:
return $default(_that.emojis);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( List<Emoji> emojis)  $default,) {final _that = this;
switch (_that) {
case _EmojiDeleted():
return $default(_that.emojis);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( List<Emoji> emojis)?  $default,) {final _that = this;
switch (_that) {
case _EmojiDeleted() when $default != null:
return $default(_that.emojis);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable(createToJson: false)

class _EmojiDeleted implements EmojiDeleted {
  const _EmojiDeleted({required final  List<Emoji> emojis}): _emojis = emojis;
  factory _EmojiDeleted.fromJson(Map<String, dynamic> json) => _$EmojiDeletedFromJson(json);

 final  List<Emoji> _emojis;
@override List<Emoji> get emojis {
  if (_emojis is EqualUnmodifiableListView) return _emojis;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_emojis);
}


/// Create a copy of EmojiDeleted
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$EmojiDeletedCopyWith<_EmojiDeleted> get copyWith => __$EmojiDeletedCopyWithImpl<_EmojiDeleted>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _EmojiDeleted&&const DeepCollectionEquality().equals(other._emojis, _emojis));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_emojis));

@override
String toString() {
  return 'EmojiDeleted(emojis: $emojis)';
}


}

/// @nodoc
abstract mixin class _$EmojiDeletedCopyWith<$Res> implements $EmojiDeletedCopyWith<$Res> {
  factory _$EmojiDeletedCopyWith(_EmojiDeleted value, $Res Function(_EmojiDeleted) _then) = __$EmojiDeletedCopyWithImpl;
@override @useResult
$Res call({
 List<Emoji> emojis
});




}
/// @nodoc
class __$EmojiDeletedCopyWithImpl<$Res>
    implements _$EmojiDeletedCopyWith<$Res> {
  __$EmojiDeletedCopyWithImpl(this._self, this._then);

  final _EmojiDeleted _self;
  final $Res Function(_EmojiDeleted) _then;

/// Create a copy of EmojiDeleted
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? emojis = null,}) {
  return _then(_EmojiDeleted(
emojis: null == emojis ? _self._emojis : emojis // ignore: cast_nullable_to_non_nullable
as List<Emoji>,
  ));
}


}


/// @nodoc
mixin _$AnnouncementCreated {

 AnnouncementsResponse get announcement;
/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AnnouncementCreatedCopyWith<AnnouncementCreated> get copyWith => _$AnnouncementCreatedCopyWithImpl<AnnouncementCreated>(this as AnnouncementCreated, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AnnouncementCreated&&(identical(other.announcement, announcement) || other.announcement == announcement));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,announcement);

@override
String toString() {
  return 'AnnouncementCreated(announcement: $announcement)';
}


}

/// @nodoc
abstract mixin class $AnnouncementCreatedCopyWith<$Res>  {
  factory $AnnouncementCreatedCopyWith(AnnouncementCreated value, $Res Function(AnnouncementCreated) _then) = _$AnnouncementCreatedCopyWithImpl;
@useResult
$Res call({
 AnnouncementsResponse announcement
});


$AnnouncementsResponseCopyWith<$Res> get announcement;

}
/// @nodoc
class _$AnnouncementCreatedCopyWithImpl<$Res>
    implements $AnnouncementCreatedCopyWith<$Res> {
  _$AnnouncementCreatedCopyWithImpl(this._self, this._then);

  final AnnouncementCreated _self;
  final $Res Function(AnnouncementCreated) _then;

/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? announcement = null,}) {
  return _then(_self.copyWith(
announcement: null == announcement ? _self.announcement : announcement // ignore: cast_nullable_to_non_nullable
as AnnouncementsResponse,
  ));
}
/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$AnnouncementsResponseCopyWith<$Res> get announcement {
  
  return $AnnouncementsResponseCopyWith<$Res>(_self.announcement, (value) {
    return _then(_self.copyWith(announcement: value));
  });
}
}


/// Adds pattern-matching-related methods to [AnnouncementCreated].
extension AnnouncementCreatedPatterns on AnnouncementCreated {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _AnnouncementCreated value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _AnnouncementCreated() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _AnnouncementCreated value)  $default,){
final _that = this;
switch (_that) {
case _AnnouncementCreated():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _AnnouncementCreated value)?  $default,){
final _that = this;
switch (_that) {
case _AnnouncementCreated() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( AnnouncementsResponse announcement)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _AnnouncementCreated() when $default != null:
return $default(_that.announcement);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( AnnouncementsResponse announcement)  $default,) {final _that = this;
switch (_that) {
case _AnnouncementCreated():
return $default(_that.announcement);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( AnnouncementsResponse announcement)?  $default,) {final _that = this;
switch (_that) {
case _AnnouncementCreated() when $default != null:
return $default(_that.announcement);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable(createToJson: false)

class _AnnouncementCreated implements AnnouncementCreated {
  const _AnnouncementCreated({required this.announcement});
  factory _AnnouncementCreated.fromJson(Map<String, dynamic> json) => _$AnnouncementCreatedFromJson(json);

@override final  AnnouncementsResponse announcement;

/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$AnnouncementCreatedCopyWith<_AnnouncementCreated> get copyWith => __$AnnouncementCreatedCopyWithImpl<_AnnouncementCreated>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _AnnouncementCreated&&(identical(other.announcement, announcement) || other.announcement == announcement));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,announcement);

@override
String toString() {
  return 'AnnouncementCreated(announcement: $announcement)';
}


}

/// @nodoc
abstract mixin class _$AnnouncementCreatedCopyWith<$Res> implements $AnnouncementCreatedCopyWith<$Res> {
  factory _$AnnouncementCreatedCopyWith(_AnnouncementCreated value, $Res Function(_AnnouncementCreated) _then) = __$AnnouncementCreatedCopyWithImpl;
@override @useResult
$Res call({
 AnnouncementsResponse announcement
});


@override $AnnouncementsResponseCopyWith<$Res> get announcement;

}
/// @nodoc
class __$AnnouncementCreatedCopyWithImpl<$Res>
    implements _$AnnouncementCreatedCopyWith<$Res> {
  __$AnnouncementCreatedCopyWithImpl(this._self, this._then);

  final _AnnouncementCreated _self;
  final $Res Function(_AnnouncementCreated) _then;

/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? announcement = null,}) {
  return _then(_AnnouncementCreated(
announcement: null == announcement ? _self.announcement : announcement // ignore: cast_nullable_to_non_nullable
as AnnouncementsResponse,
  ));
}

/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$AnnouncementsResponseCopyWith<$Res> get announcement {
  
  return $AnnouncementsResponseCopyWith<$Res>(_self.announcement, (value) {
    return _then(_self.copyWith(announcement: value));
  });
}
}

// dart format on

// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'broadcast.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$EmojiAdded {

 Emoji get emoji;
/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$EmojiAddedCopyWith<EmojiAdded> get copyWith => _$EmojiAddedCopyWithImpl<EmojiAdded>(this as EmojiAdded, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is EmojiAdded&&(identical(other.emoji, emoji) || other.emoji == emoji));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,emoji);

@override
String toString() {
  return 'EmojiAdded(emoji: $emoji)';
}


}

/// @nodoc
abstract mixin class $EmojiAddedCopyWith<$Res>  {
  factory $EmojiAddedCopyWith(EmojiAdded value, $Res Function(EmojiAdded) _then) = _$EmojiAddedCopyWithImpl;
@useResult
$Res call({
 Emoji emoji
});


$EmojiCopyWith<$Res> get emoji;

}
/// @nodoc
class _$EmojiAddedCopyWithImpl<$Res>
    implements $EmojiAddedCopyWith<$Res> {
  _$EmojiAddedCopyWithImpl(this._self, this._then);

  final EmojiAdded _self;
  final $Res Function(EmojiAdded) _then;

/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? emoji = null,}) {
  return _then(_self.copyWith(
emoji: null == emoji ? _self.emoji : emoji // ignore: cast_nullable_to_non_nullable
as Emoji,
  ));
}
/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$EmojiCopyWith<$Res> get emoji {
  
  return $EmojiCopyWith<$Res>(_self.emoji, (value) {
    return _then(_self.copyWith(emoji: value));
  });
}
}


/// @nodoc
@JsonSerializable(createToJson: false)

class _EmojiAdded implements EmojiAdded {
  const _EmojiAdded({required this.emoji});
  factory _EmojiAdded.fromJson(Map<String, dynamic> json) => _$EmojiAddedFromJson(json);

@override final  Emoji emoji;

/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$EmojiAddedCopyWith<_EmojiAdded> get copyWith => __$EmojiAddedCopyWithImpl<_EmojiAdded>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _EmojiAdded&&(identical(other.emoji, emoji) || other.emoji == emoji));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,emoji);

@override
String toString() {
  return 'EmojiAdded(emoji: $emoji)';
}


}

/// @nodoc
abstract mixin class _$EmojiAddedCopyWith<$Res> implements $EmojiAddedCopyWith<$Res> {
  factory _$EmojiAddedCopyWith(_EmojiAdded value, $Res Function(_EmojiAdded) _then) = __$EmojiAddedCopyWithImpl;
@override @useResult
$Res call({
 Emoji emoji
});


@override $EmojiCopyWith<$Res> get emoji;

}
/// @nodoc
class __$EmojiAddedCopyWithImpl<$Res>
    implements _$EmojiAddedCopyWith<$Res> {
  __$EmojiAddedCopyWithImpl(this._self, this._then);

  final _EmojiAdded _self;
  final $Res Function(_EmojiAdded) _then;

/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? emoji = null,}) {
  return _then(_EmojiAdded(
emoji: null == emoji ? _self.emoji : emoji // ignore: cast_nullable_to_non_nullable
as Emoji,
  ));
}

/// Create a copy of EmojiAdded
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$EmojiCopyWith<$Res> get emoji {
  
  return $EmojiCopyWith<$Res>(_self.emoji, (value) {
    return _then(_self.copyWith(emoji: value));
  });
}
}


/// @nodoc
mixin _$EmojiUpdated {

 List<Emoji> get emojis;
/// Create a copy of EmojiUpdated
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$EmojiUpdatedCopyWith<EmojiUpdated> get copyWith => _$EmojiUpdatedCopyWithImpl<EmojiUpdated>(this as EmojiUpdated, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is EmojiUpdated&&const DeepCollectionEquality().equals(other.emojis, emojis));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(emojis));

@override
String toString() {
  return 'EmojiUpdated(emojis: $emojis)';
}


}

/// @nodoc
abstract mixin class $EmojiUpdatedCopyWith<$Res>  {
  factory $EmojiUpdatedCopyWith(EmojiUpdated value, $Res Function(EmojiUpdated) _then) = _$EmojiUpdatedCopyWithImpl;
@useResult
$Res call({
 List<Emoji> emojis
});




}
/// @nodoc
class _$EmojiUpdatedCopyWithImpl<$Res>
    implements $EmojiUpdatedCopyWith<$Res> {
  _$EmojiUpdatedCopyWithImpl(this._self, this._then);

  final EmojiUpdated _self;
  final $Res Function(EmojiUpdated) _then;

/// Create a copy of EmojiUpdated
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? emojis = null,}) {
  return _then(_self.copyWith(
emojis: null == emojis ? _self.emojis : emojis // ignore: cast_nullable_to_non_nullable
as List<Emoji>,
  ));
}

}


/// @nodoc
@JsonSerializable(createToJson: false)

class _EmojiUpdated implements EmojiUpdated {
  const _EmojiUpdated({required final  List<Emoji> emojis}): _emojis = emojis;
  factory _EmojiUpdated.fromJson(Map<String, dynamic> json) => _$EmojiUpdatedFromJson(json);

 final  List<Emoji> _emojis;
@override List<Emoji> get emojis {
  if (_emojis is EqualUnmodifiableListView) return _emojis;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_emojis);
}


/// Create a copy of EmojiUpdated
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$EmojiUpdatedCopyWith<_EmojiUpdated> get copyWith => __$EmojiUpdatedCopyWithImpl<_EmojiUpdated>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _EmojiUpdated&&const DeepCollectionEquality().equals(other._emojis, _emojis));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_emojis));

@override
String toString() {
  return 'EmojiUpdated(emojis: $emojis)';
}


}

/// @nodoc
abstract mixin class _$EmojiUpdatedCopyWith<$Res> implements $EmojiUpdatedCopyWith<$Res> {
  factory _$EmojiUpdatedCopyWith(_EmojiUpdated value, $Res Function(_EmojiUpdated) _then) = __$EmojiUpdatedCopyWithImpl;
@override @useResult
$Res call({
 List<Emoji> emojis
});




}
/// @nodoc
class __$EmojiUpdatedCopyWithImpl<$Res>
    implements _$EmojiUpdatedCopyWith<$Res> {
  __$EmojiUpdatedCopyWithImpl(this._self, this._then);

  final _EmojiUpdated _self;
  final $Res Function(_EmojiUpdated) _then;

/// Create a copy of EmojiUpdated
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? emojis = null,}) {
  return _then(_EmojiUpdated(
emojis: null == emojis ? _self._emojis : emojis // ignore: cast_nullable_to_non_nullable
as List<Emoji>,
  ));
}


}


/// @nodoc
mixin _$EmojiDeleted {

 List<Emoji> get emojis;
/// Create a copy of EmojiDeleted
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$EmojiDeletedCopyWith<EmojiDeleted> get copyWith => _$EmojiDeletedCopyWithImpl<EmojiDeleted>(this as EmojiDeleted, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is EmojiDeleted&&const DeepCollectionEquality().equals(other.emojis, emojis));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(emojis));

@override
String toString() {
  return 'EmojiDeleted(emojis: $emojis)';
}


}

/// @nodoc
abstract mixin class $EmojiDeletedCopyWith<$Res>  {
  factory $EmojiDeletedCopyWith(EmojiDeleted value, $Res Function(EmojiDeleted) _then) = _$EmojiDeletedCopyWithImpl;
@useResult
$Res call({
 List<Emoji> emojis
});




}
/// @nodoc
class _$EmojiDeletedCopyWithImpl<$Res>
    implements $EmojiDeletedCopyWith<$Res> {
  _$EmojiDeletedCopyWithImpl(this._self, this._then);

  final EmojiDeleted _self;
  final $Res Function(EmojiDeleted) _then;

/// Create a copy of EmojiDeleted
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? emojis = null,}) {
  return _then(_self.copyWith(
emojis: null == emojis ? _self.emojis : emojis // ignore: cast_nullable_to_non_nullable
as List<Emoji>,
  ));
}

}


/// @nodoc
@JsonSerializable(createToJson: false)

class _EmojiDeleted implements EmojiDeleted {
  const _EmojiDeleted({required final  List<Emoji> emojis}): _emojis = emojis;
  factory _EmojiDeleted.fromJson(Map<String, dynamic> json) => _$EmojiDeletedFromJson(json);

 final  List<Emoji> _emojis;
@override List<Emoji> get emojis {
  if (_emojis is EqualUnmodifiableListView) return _emojis;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_emojis);
}


/// Create a copy of EmojiDeleted
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$EmojiDeletedCopyWith<_EmojiDeleted> get copyWith => __$EmojiDeletedCopyWithImpl<_EmojiDeleted>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _EmojiDeleted&&const DeepCollectionEquality().equals(other._emojis, _emojis));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_emojis));

@override
String toString() {
  return 'EmojiDeleted(emojis: $emojis)';
}


}

/// @nodoc
abstract mixin class _$EmojiDeletedCopyWith<$Res> implements $EmojiDeletedCopyWith<$Res> {
  factory _$EmojiDeletedCopyWith(_EmojiDeleted value, $Res Function(_EmojiDeleted) _then) = __$EmojiDeletedCopyWithImpl;
@override @useResult
$Res call({
 List<Emoji> emojis
});




}
/// @nodoc
class __$EmojiDeletedCopyWithImpl<$Res>
    implements _$EmojiDeletedCopyWith<$Res> {
  __$EmojiDeletedCopyWithImpl(this._self, this._then);

  final _EmojiDeleted _self;
  final $Res Function(_EmojiDeleted) _then;

/// Create a copy of EmojiDeleted
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? emojis = null,}) {
  return _then(_EmojiDeleted(
emojis: null == emojis ? _self._emojis : emojis // ignore: cast_nullable_to_non_nullable
as List<Emoji>,
  ));
}


}


/// @nodoc
mixin _$AnnouncementCreated {

 AnnouncementsResponse get announcement;
/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AnnouncementCreatedCopyWith<AnnouncementCreated> get copyWith => _$AnnouncementCreatedCopyWithImpl<AnnouncementCreated>(this as AnnouncementCreated, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AnnouncementCreated&&(identical(other.announcement, announcement) || other.announcement == announcement));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,announcement);

@override
String toString() {
  return 'AnnouncementCreated(announcement: $announcement)';
}


}

/// @nodoc
abstract mixin class $AnnouncementCreatedCopyWith<$Res>  {
  factory $AnnouncementCreatedCopyWith(AnnouncementCreated value, $Res Function(AnnouncementCreated) _then) = _$AnnouncementCreatedCopyWithImpl;
@useResult
$Res call({
 AnnouncementsResponse announcement
});


$AnnouncementsResponseCopyWith<$Res> get announcement;

}
/// @nodoc
class _$AnnouncementCreatedCopyWithImpl<$Res>
    implements $AnnouncementCreatedCopyWith<$Res> {
  _$AnnouncementCreatedCopyWithImpl(this._self, this._then);

  final AnnouncementCreated _self;
  final $Res Function(AnnouncementCreated) _then;

/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? announcement = null,}) {
  return _then(_self.copyWith(
announcement: null == announcement ? _self.announcement : announcement // ignore: cast_nullable_to_non_nullable
as AnnouncementsResponse,
  ));
}
/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$AnnouncementsResponseCopyWith<$Res> get announcement {
  
  return $AnnouncementsResponseCopyWith<$Res>(_self.announcement, (value) {
    return _then(_self.copyWith(announcement: value));
  });
}
}


/// @nodoc
@JsonSerializable(createToJson: false)

class _AnnouncementCreated implements AnnouncementCreated {
  const _AnnouncementCreated({required this.announcement});
  factory _AnnouncementCreated.fromJson(Map<String, dynamic> json) => _$AnnouncementCreatedFromJson(json);

@override final  AnnouncementsResponse announcement;

/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$AnnouncementCreatedCopyWith<_AnnouncementCreated> get copyWith => __$AnnouncementCreatedCopyWithImpl<_AnnouncementCreated>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _AnnouncementCreated&&(identical(other.announcement, announcement) || other.announcement == announcement));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,announcement);

@override
String toString() {
  return 'AnnouncementCreated(announcement: $announcement)';
}


}

/// @nodoc
abstract mixin class _$AnnouncementCreatedCopyWith<$Res> implements $AnnouncementCreatedCopyWith<$Res> {
  factory _$AnnouncementCreatedCopyWith(_AnnouncementCreated value, $Res Function(_AnnouncementCreated) _then) = __$AnnouncementCreatedCopyWithImpl;
@override @useResult
$Res call({
 AnnouncementsResponse announcement
});


@override $AnnouncementsResponseCopyWith<$Res> get announcement;

}
/// @nodoc
class __$AnnouncementCreatedCopyWithImpl<$Res>
    implements _$AnnouncementCreatedCopyWith<$Res> {
  __$AnnouncementCreatedCopyWithImpl(this._self, this._then);

  final _AnnouncementCreated _self;
  final $Res Function(_AnnouncementCreated) _then;

/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? announcement = null,}) {
  return _then(_AnnouncementCreated(
announcement: null == announcement ? _self.announcement : announcement // ignore: cast_nullable_to_non_nullable
as AnnouncementsResponse,
  ));
}

/// Create a copy of AnnouncementCreated
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$AnnouncementsResponseCopyWith<$Res> get announcement {
  
  return $AnnouncementsResponseCopyWith<$Res>(_self.announcement, (value) {
    return _then(_self.copyWith(announcement: value));
  });
}
}

// dart format on

// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'ui.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `create_component_instance`, `register`, `update`, `update`, `update`, `update`, `update`, `update`, `update`, `update`, `update`, `update`, `update`, `update`, `update`, `update`, `update`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AsUiButtonCallback>>
abstract class AsUiButtonCallback implements RustOpaqueInterface {
  Future<void> call();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< AsUiLib>>
abstract class AsUiLib implements RustOpaqueInterface {
  factory AsUiLib(
          {required FutureOr<void> Function(String, AsUiComponent) onUpdate}) =>
      RustLib.instance.api.crateApiAiscriptUiAsUiLibNew(onUpdate: onUpdate);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AsUiMfmCallback>>
abstract class AsUiMfmCallback implements RustOpaqueInterface {
  Future<void> call({required String value});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AsUiNumberCallback>>
abstract class AsUiNumberCallback implements RustOpaqueInterface {
  Future<void> call({required double value});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AsUiSelectCallback>>
abstract class AsUiSelectCallback implements RustOpaqueInterface {
  Future<void> call({required String value});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AsUiSwitchCallback>>
abstract class AsUiSwitchCallback implements RustOpaqueInterface {
  Future<void> call({required bool value});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AsUiTextInputCallback>>
abstract class AsUiTextInputCallback implements RustOpaqueInterface {
  Future<void> call({required String value});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AsUiTextareaCallback>>
abstract class AsUiTextareaCallback implements RustOpaqueInterface {
  Future<void> call({required String value});
}

class AsUiButton {
  final String? text;
  final AsUiButtonCallback? onClick;
  final bool? primary;
  final bool? rounded;
  final bool? disabled;

  const AsUiButton({
    this.text,
    this.onClick,
    this.primary,
    this.rounded,
    this.disabled,
  });

  @override
  int get hashCode =>
      text.hashCode ^
      onClick.hashCode ^
      primary.hashCode ^
      rounded.hashCode ^
      disabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiButton &&
          runtimeType == other.runtimeType &&
          text == other.text &&
          onClick == other.onClick &&
          primary == other.primary &&
          rounded == other.rounded &&
          disabled == other.disabled;
}

class AsUiButtons {
  final List<AsUiButton>? buttons;

  const AsUiButtons({
    this.buttons,
  });

  @override
  int get hashCode => buttons.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiButtons &&
          runtimeType == other.runtimeType &&
          buttons == other.buttons;
}

@freezed
sealed class AsUiComponent with _$AsUiComponent {
  const AsUiComponent._();

  const factory AsUiComponent.root(
    AsUiRoot field0,
  ) = AsUiComponent_Root;
  const factory AsUiComponent.container(
    AsUiContainer field0,
  ) = AsUiComponent_Container;
  const factory AsUiComponent.text(
    AsUiText field0,
  ) = AsUiComponent_Text;
  const factory AsUiComponent.mfm(
    AsUiMfm field0,
  ) = AsUiComponent_Mfm;
  const factory AsUiComponent.button(
    AsUiButton field0,
  ) = AsUiComponent_Button;
  const factory AsUiComponent.buttons(
    AsUiButtons field0,
  ) = AsUiComponent_Buttons;
  const factory AsUiComponent.toggleSwitch(
    AsUiSwitch field0,
  ) = AsUiComponent_ToggleSwitch;
  const factory AsUiComponent.textarea(
    AsUiTextarea field0,
  ) = AsUiComponent_Textarea;
  const factory AsUiComponent.textInput(
    AsUiTextInput field0,
  ) = AsUiComponent_TextInput;
  const factory AsUiComponent.numberInput(
    AsUiNumberInput field0,
  ) = AsUiComponent_NumberInput;
  const factory AsUiComponent.select(
    AsUiSelect field0,
  ) = AsUiComponent_Select;
  const factory AsUiComponent.folder(
    AsUiFolder field0,
  ) = AsUiComponent_Folder;
  const factory AsUiComponent.postFormButton(
    AsUiPostFormButton field0,
  ) = AsUiComponent_PostFormButton;
  const factory AsUiComponent.postForm(
    AsUiPostForm field0,
  ) = AsUiComponent_PostForm;
}

class AsUiContainer {
  final List<String>? children;
  final String? align;
  final String? bgColor;
  final String? fgColor;
  final String? font;
  final double? borderWidth;
  final String? borderColor;
  final double? padding;
  final bool? rounded;
  final bool? hidden;

  const AsUiContainer({
    this.children,
    this.align,
    this.bgColor,
    this.fgColor,
    this.font,
    this.borderWidth,
    this.borderColor,
    this.padding,
    this.rounded,
    this.hidden,
  });

  @override
  int get hashCode =>
      children.hashCode ^
      align.hashCode ^
      bgColor.hashCode ^
      fgColor.hashCode ^
      font.hashCode ^
      borderWidth.hashCode ^
      borderColor.hashCode ^
      padding.hashCode ^
      rounded.hashCode ^
      hidden.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiContainer &&
          runtimeType == other.runtimeType &&
          children == other.children &&
          align == other.align &&
          bgColor == other.bgColor &&
          fgColor == other.fgColor &&
          font == other.font &&
          borderWidth == other.borderWidth &&
          borderColor == other.borderColor &&
          padding == other.padding &&
          rounded == other.rounded &&
          hidden == other.hidden;
}

class AsUiFolder {
  final List<String>? children;
  final String? title;
  final bool? opened;

  const AsUiFolder({
    this.children,
    this.title,
    this.opened,
  });

  @override
  int get hashCode => children.hashCode ^ title.hashCode ^ opened.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiFolder &&
          runtimeType == other.runtimeType &&
          children == other.children &&
          title == other.title &&
          opened == other.opened;
}

class AsUiMfm {
  final String? text;
  final double? size;
  final bool? bold;
  final String? color;
  final String? font;
  final AsUiMfmCallback? onClickEv;

  const AsUiMfm({
    this.text,
    this.size,
    this.bold,
    this.color,
    this.font,
    this.onClickEv,
  });

  @override
  int get hashCode =>
      text.hashCode ^
      size.hashCode ^
      bold.hashCode ^
      color.hashCode ^
      font.hashCode ^
      onClickEv.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiMfm &&
          runtimeType == other.runtimeType &&
          text == other.text &&
          size == other.size &&
          bold == other.bold &&
          color == other.color &&
          font == other.font &&
          onClickEv == other.onClickEv;
}

class AsUiNumberInput {
  final AsUiNumberCallback? onInput;
  final double? defaultValue;
  final String? label;
  final String? caption;

  const AsUiNumberInput({
    this.onInput,
    this.defaultValue,
    this.label,
    this.caption,
  });

  @override
  int get hashCode =>
      onInput.hashCode ^
      defaultValue.hashCode ^
      label.hashCode ^
      caption.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiNumberInput &&
          runtimeType == other.runtimeType &&
          onInput == other.onInput &&
          defaultValue == other.defaultValue &&
          label == other.label &&
          caption == other.caption;
}

class AsUiPostForm {
  final PostFormPropsForAsUi? form;

  const AsUiPostForm({
    this.form,
  });

  @override
  int get hashCode => form.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiPostForm &&
          runtimeType == other.runtimeType &&
          form == other.form;
}

class AsUiPostFormButton {
  final String? text;
  final bool? primary;
  final bool? rounded;
  final PostFormPropsForAsUi? form;

  const AsUiPostFormButton({
    this.text,
    this.primary,
    this.rounded,
    this.form,
  });

  @override
  int get hashCode =>
      text.hashCode ^ primary.hashCode ^ rounded.hashCode ^ form.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiPostFormButton &&
          runtimeType == other.runtimeType &&
          text == other.text &&
          primary == other.primary &&
          rounded == other.rounded &&
          form == other.form;
}

class AsUiRoot {
  final List<String> children;

  const AsUiRoot({
    required this.children,
  });

  @override
  int get hashCode => children.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiRoot &&
          runtimeType == other.runtimeType &&
          children == other.children;
}

class AsUiSelect {
  final List<(String, String)>? items;
  final AsUiSelectCallback? onChange;
  final String? defaultValue;
  final String? label;
  final String? caption;

  const AsUiSelect({
    this.items,
    this.onChange,
    this.defaultValue,
    this.label,
    this.caption,
  });

  @override
  int get hashCode =>
      items.hashCode ^
      onChange.hashCode ^
      defaultValue.hashCode ^
      label.hashCode ^
      caption.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiSelect &&
          runtimeType == other.runtimeType &&
          items == other.items &&
          onChange == other.onChange &&
          defaultValue == other.defaultValue &&
          label == other.label &&
          caption == other.caption;
}

class AsUiSwitch {
  final AsUiSwitchCallback? onChange;
  final bool? defaultValue;
  final String? label;
  final String? caption;

  const AsUiSwitch({
    this.onChange,
    this.defaultValue,
    this.label,
    this.caption,
  });

  @override
  int get hashCode =>
      onChange.hashCode ^
      defaultValue.hashCode ^
      label.hashCode ^
      caption.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiSwitch &&
          runtimeType == other.runtimeType &&
          onChange == other.onChange &&
          defaultValue == other.defaultValue &&
          label == other.label &&
          caption == other.caption;
}

class AsUiText {
  final String? text;
  final double? size;
  final bool? bold;
  final String? color;
  final String? font;

  const AsUiText({
    this.text,
    this.size,
    this.bold,
    this.color,
    this.font,
  });

  @override
  int get hashCode =>
      text.hashCode ^
      size.hashCode ^
      bold.hashCode ^
      color.hashCode ^
      font.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiText &&
          runtimeType == other.runtimeType &&
          text == other.text &&
          size == other.size &&
          bold == other.bold &&
          color == other.color &&
          font == other.font;
}

class AsUiTextInput {
  final AsUiTextInputCallback? onInput;
  final String? defaultValue;
  final String? label;
  final String? caption;

  const AsUiTextInput({
    this.onInput,
    this.defaultValue,
    this.label,
    this.caption,
  });

  @override
  int get hashCode =>
      onInput.hashCode ^
      defaultValue.hashCode ^
      label.hashCode ^
      caption.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiTextInput &&
          runtimeType == other.runtimeType &&
          onInput == other.onInput &&
          defaultValue == other.defaultValue &&
          label == other.label &&
          caption == other.caption;
}

class AsUiTextarea {
  final AsUiTextareaCallback? onInput;
  final String? defaultValue;
  final String? label;
  final String? caption;

  const AsUiTextarea({
    this.onInput,
    this.defaultValue,
    this.label,
    this.caption,
  });

  @override
  int get hashCode =>
      onInput.hashCode ^
      defaultValue.hashCode ^
      label.hashCode ^
      caption.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsUiTextarea &&
          runtimeType == other.runtimeType &&
          onInput == other.onInput &&
          defaultValue == other.defaultValue &&
          label == other.label &&
          caption == other.caption;
}

class PostFormPropsForAsUi {
  final String text;
  final String? cw;
  final String? visibility;
  final bool? localOnly;

  const PostFormPropsForAsUi({
    required this.text,
    this.cw,
    this.visibility,
    this.localOnly,
  });

  @override
  int get hashCode =>
      text.hashCode ^ cw.hashCode ^ visibility.hashCode ^ localOnly.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PostFormPropsForAsUi &&
          runtimeType == other.runtimeType &&
          text == other.text &&
          cw == other.cw &&
          visibility == other.visibility &&
          localOnly == other.localOnly;
}
